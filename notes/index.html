<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>学习笔记 | Meatha</title>
    <meta name="description" content="我的个人网站">
    <link rel="icon" href="/logo.ico">
  <link rel="manifest" href="/logo.ico">
  <link rel="apple-touch-icon" href="/logo.ico">
    
    <link rel="preload" href="/assets/css/0.styles.5fced7b3.css" as="style"><link rel="preload" href="/assets/js/app.6c972312.js" as="script"><link rel="preload" href="/assets/js/5.94bb3ea4.js" as="script"><link rel="prefetch" href="/assets/js/2.856d2f75.js"><link rel="prefetch" href="/assets/js/3.07475cff.js"><link rel="prefetch" href="/assets/js/4.cdbe10ff.js"><link rel="prefetch" href="/assets/js/6.ac619b0f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.5fced7b3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Meatha</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">搭建博客</a></div><div class="nav-item"><a href="/notes/" class="nav-link router-link-exact-active router-link-active">学习笔记</a></div><div class="nav-item"><a href="https://github.com/Meatha" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">搭建博客</a></div><div class="nav-item"><a href="/notes/" class="nav-link router-link-exact-active router-link-active">学习笔记</a></div><div class="nav-item"><a href="https://github.com/Meatha" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>学习笔记</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/notes/#git" class="sidebar-link">Git</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/#git基本命令" class="sidebar-link">Git基本命令</a></li><li class="sidebar-sub-header"><a href="/notes/#远程仓库" class="sidebar-link">远程仓库</a></li><li class="sidebar-sub-header"><a href="/notes/#创建与合并分支" class="sidebar-link">创建与合并分支</a></li><li class="sidebar-sub-header"><a href="/notes/#feature-分支" class="sidebar-link">Feature 分支</a></li><li class="sidebar-sub-header"><a href="/notes/#bug-分支" class="sidebar-link">bug 分支</a></li><li class="sidebar-sub-header"><a href="/notes/#多人协作" class="sidebar-link">多人协作</a></li></ul></li><li><a href="/notes/#typescript基础" class="sidebar-link">TypeScript基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/#基础类型" class="sidebar-link">基础类型</a></li><li class="sidebar-sub-header"><a href="/notes/#变量声明" class="sidebar-link">变量声明</a></li><li class="sidebar-sub-header"><a href="/notes/#接口" class="sidebar-link">接口</a></li><li class="sidebar-sub-header"><a href="/notes/#类" class="sidebar-link">类</a></li><li class="sidebar-sub-header"><a href="/notes/#函数" class="sidebar-link">函数</a></li><li class="sidebar-sub-header"><a href="/notes/#泛型" class="sidebar-link">泛型</a></li><li class="sidebar-sub-header"><a href="/notes/#枚举" class="sidebar-link">枚举</a></li><li class="sidebar-sub-header"><a href="/notes/#类型推论" class="sidebar-link">类型推论</a></li><li class="sidebar-sub-header"><a href="/notes/#类型兼容性" class="sidebar-link">类型兼容性</a></li><li class="sidebar-sub-header"><a href="/notes/#高级类型" class="sidebar-link">高级类型</a></li><li class="sidebar-sub-header"><a href="/notes/#symbol" class="sidebar-link">Symbol</a></li><li class="sidebar-sub-header"><a href="/notes/#迭代器和生成器" class="sidebar-link">迭代器和生成器</a></li><li class="sidebar-sub-header"><a href="/notes/#模块" class="sidebar-link">模块</a></li><li class="sidebar-sub-header"><a href="/notes/#命名空间" class="sidebar-link">命名空间</a></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h2 id="git"><a href="#git" aria-hidden="true" class="header-anchor">#</a> Git</h2> <h3 id="git基本命令"><a href="#git基本命令" aria-hidden="true" class="header-anchor">#</a> Git基本命令</h3> <h4 id="初始化一个git仓库"><a href="#初始化一个git仓库" aria-hidden="true" class="header-anchor">#</a> 初始化一个Git仓库</h4> <p><code>git init</code></p> <h4 id="添加文件到git仓库"><a href="#添加文件到git仓库" aria-hidden="true" class="header-anchor">#</a> 添加文件到Git仓库</h4> <p><code>git add &lt;file&gt;</code></p> <h4 id="提交文件到git仓库"><a href="#提交文件到git仓库" aria-hidden="true" class="header-anchor">#</a> 提交文件到Git仓库</h4> <p><code>git commit -m &lt;message&gt;</code></p> <h4 id="查看仓库当前的状态"><a href="#查看仓库当前的状态" aria-hidden="true" class="header-anchor">#</a> 查看仓库当前的状态</h4> <p><code>git status</code></p> <h4 id="查看当前文件做了什么修改"><a href="#查看当前文件做了什么修改" aria-hidden="true" class="header-anchor">#</a> 查看当前文件做了什么修改</h4> <p><code>git difference</code></p> <h3 id="远程仓库"><a href="#远程仓库" aria-hidden="true" class="header-anchor">#</a> 远程仓库</h3> <p>Git是分布式版本控制系统, 同一个Git仓库, 可以分部到不同的机器上.</p> <p>最早, 只有一台机器有一个原始版本库, 此后, 别的机器可以&quot;克隆&quot;这个原始版本库, 而且每台机器的版本库其实都是一样的.</p> <p>本地的Git仓库和Git仓库之间的传输是通过SSH加密的.</p> <p><strong>远程准备 :</strong></p> <ol><li>创建SSH Key: <code>ssh-keygen -t rsa -C &quot;your email @example.com&quot;</code>(如果一切顺利的话, 可以再用户主目录里找到 <code>.ssh</code> 目录, <code>id_rsa</code> 是私钥, <code>id_rsa.pub</code> 是公钥)</li> <li>登录 GitHub, 打开&quot;Account settings&quot;, &quot;SSH Keys&quot;页面: 然后, 点&quot;Add SSH Key&quot;, 填上任意Title, 在Key文本框里粘贴 <code>id_rsa.pub</code> 文件的内容.</li></ol> <p><strong>注 :</strong> 为什么GitHub需要SSH Key呢?</p> <p>因为GitHub需要识别出你推送的提交确实是你推送的, 而不是别人冒充的, 而Git支持SSH协议, 所以, GitHub 只要知道了你的公钥, 就可以确认只有你自己才能推送.</p> <h4 id="_1-先有本地库-关联远程库"><a href="#_1-先有本地库-关联远程库" aria-hidden="true" class="header-anchor">#</a> 1. 先有本地库, 关联远程库</h4> <p><code>git remote add origin git@github.com:michaelliao/learngit.git</code></p> <blockquote><p>从远程的仓库克隆到本地的仓库</p></blockquote> <p><strong>注 :</strong> 远程库的名字就是 <code>origin</code>, 这是Git默认的叫法.</p> <p>下一步, 就可以把本地仓库的所有内容都推送到远程库上:</p> <p><code>git push -u origin master</code></p> <p>由于远程库时空的, 我们第一次推送 <code>master</code> 分支时, 加上了 <code>-u</code> 参数, Git不但会把本地的 <code>master</code> 分支内容推送远程新的 <code>master</code> 分支, 还会把本地的 <code>master</code> 分支和远程的 <code>master</code> 分支关联起来, 在以后的推送或者拉取时就可以简化命令.</p> <p>此后, 每次本地提交后, 只要有必要, 就可以使用命令 <code>git push origin master</code> 推送最新修改.</p> <h4 id="_2-先建远程库-然后从远程库克隆"><a href="#_2-先建远程库-然后从远程库克隆" aria-hidden="true" class="header-anchor">#</a> 2. 先建远程库, 然后从远程库克隆</h4> <p><code>git clone git@github.com:michaelliao/gitskills.git</code></p> <p>然后进入 <code>gitskills</code> 目录看看</p> <pre><code>$ cd gitskills
$ ls
</code></pre> <h3 id="创建与合并分支"><a href="#创建与合并分支" aria-hidden="true" class="header-anchor">#</a> 创建与合并分支</h3> <p>在Git里, 主分支是 <code>master</code> 分支. <code>HEAD</code> 严格来说不是指向提交, 而是指向 <code>master</code> , <code>master</code> 才是指向提交的, 所以, <code>HEAD</code> 指向的就是当前分支.</p> <p>一开始的时候, <code>master</code> 分支是一条线, Git用 <code>master</code> 指向最新的提交, 再用 <code>HEAD</code> 指向 <code>master</code> , 就能确定当前分支, 以及分支的提交点.</p> <p>步骤:</p> <ol><li><p>创建 <code>dev</code> 分支</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 创建分支
git branch dev

// 切换分支
git checkout dev
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>// 创建加切换分支
git checkout -b dev
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>然后, 用<code>git branch</code>命令查看当前分支:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>git branch
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>git branch</code> 命令会列出所有分支, 当前分支前面会标一个<code>*</code>号</p></li> <li><p>切换分支</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>git checkout master
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>合并分支</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>git merge dev
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>git merge</code> 命令用于合并指定分支到当前分支.</p></li> <li><p>删除分支</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>git branch -d dev
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol> <h3 id="feature-分支"><a href="#feature-分支" aria-hidden="true" class="header-anchor">#</a> Feature 分支</h3> <p>每添加一个新功能, 最好新建一个 feature 分支, 在上面开发, 完成后合并, 最后删除该分支.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 1. 创建分支
git checkout -b xxx
    
// 2. 合并分支
git checkout dev
    
// 3. 删除分支
git branch -d xxx
    
// 4. 分支还没有合并的时候强制删除
git branch -D xxx
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="bug-分支"><a href="#bug-分支" aria-hidden="true" class="header-anchor">#</a> bug 分支</h3> <p>使用场景: 当你要修复一个 bug 时, 当前正在 <code>dev</code> 上进行的工作还没有提交.</p> <p><code>dev</code> 上的工作只进行到一半, 还没法提交, 预计完成还需1天时间. 但是必须在两小时内修复 bug 怎么办?</p> <p>Git 提供了一个 <code>stash</code> 功能, 可以把当前工作现场&quot;储藏&quot;起来, 等以后恢复现场后继续工作:</p> <p><code>git stash</code> 暂存修改</p> <p><code>git status</code> 查看工作区</p> <p>首先,确定要在哪个分支上修复bug</p> <p><code>git checkout master</code> 切换到需要修复bug 的分支上</p> <p><code>git checkout -b bug-issue</code> 新建bug修复的分支</p> <p>在 bug-issue 分支上修改, 然后 commit .</p> <p>修复完成后, 切换到 <code>master</code> 分支, 并完成合并, 最后删除 bug 分支.</p> <p><code>git stash list</code> 查看暂存区的所有暂存信息</p> <p><code>git stash apply</code> 恢复暂存区的内容, 但是 stash 内容并不删除.</p> <p><code>git stash drop</code> 删除暂存区的内容</p> <p><code>git stash pop</code> 恢复暂存区的内容, 并删除暂存区的内容.</p> <p>多次 <code>stash</code> 的时候, 可以先用 <code>git stash list</code> 查看, 然后回复指定的 stash</p> <p><code>git stash apply stash@{0}</code> 恢复指定的 stash</p> <h5 id="小结"><a href="#小结" aria-hidden="true" class="header-anchor">#</a> 小结:</h5> <p>修复 bug 时, 我们会通过创建新的 bug 分支进行修复, 然后合并, 最后删除;</p> <p>当手头的工作没有完成时, 先把工作现场<code>git stash</code>一下, 然后去修复bug, 修复后, 再<code>git stash pop</code>, 回到工作现场.</p> <h3 id="多人协作"><a href="#多人协作" aria-hidden="true" class="header-anchor">#</a> 多人协作</h3> <p>当你从远程仓库克隆时, 实际上Git 自动把本地的 <code>master</code> 分支和远程的 <code>master</code> 分支对应起来了, 并且, 远程仓库的默认名称是 <code>origin</code>.</p> <p><code>git remote</code> 查看远程库的信息.</p> <p><code>git remote -v</code> 显示更详细的信息.</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ git remote -v
origin  git@github.com:michaelliao/learngit.git (fetch)
origin  git@github.com:michaelliao/learngit.git (push)

// 显示了 可以抓取和推送的 origin 的地址.
// 如果没有推送权限, 就看不到 push 的地址.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="typescript基础"><a href="#typescript基础" aria-hidden="true" class="header-anchor">#</a> TypeScript基础</h2> <h3 id="基础类型"><a href="#基础类型" aria-hidden="true" class="header-anchor">#</a> 基础类型</h3> <p>TypeScript的基础类型和JavaScript的基础类型几乎相同。</p> <pre><code>// 布尔值
let isDone: boolean = false;

// 所有的数字都是浮点数， 支持 十进制 十六进制 还有 二进制和八进制
let decLiteral: number = 6;
let hexLiteral: number = 0xf00d;
let binaryLiteral: number = 0b1010;
let octalLiteral: number = 0o744;

// 字符串
let name: string = &quot;Jane&quot;;
let name: string = `Gane`;
let sentence: string = `Hello, my name is ${name}`;

// 数组
let list: number[] = [1, 2, 3, 4];
let list: Array&lt;number&gt; = [1, 2, 3, 4];

// Null 和 Undefined
let u: undefined = undefined;
let n: null = null;

// Object (object 表示非原始类型)
declare function create(o: object | null): void;

create({ prop: 0 }); // ok
create(null); // ok

create(42); // error 42 属于 number 类型
</code></pre> <p><strong>元祖 Tuple</strong> (新增类型)</p> <p>元祖类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。</p> <pre><code>let x: [string, number];
x = ['hello', 10]; // ok
x = [10, 'hello']; // error
</code></pre> <p><strong>枚举 emum</strong></p> <p>enum 类型是对JavaScript标准数据类型的补充。</p> <pre><code>enum Color {Red = 1, Green, Blue = 4}
let c: Color = Color.Green;
// c = 2

// 枚举类型提供的一个便利是可以通过枚举的值得到它的名字.
let colorName: string = Color[4]; 
// colorName = Blue
</code></pre> <p><strong>Any</strong></p> <p>为不确定类型的变量指定一个类型.</p> <pre><code>let noSure: any = 4;
notSure = &quot;maybe a string instead&quot;;
notSure = false;

let list: any[] = [1, true, &quot;free&quot;];
list[1] = 100;

// Object 类型的变量只允许赋值, 不能够调用任意方法, any类型可以调用方法

let noSure: any = 4;
notSure.ifItExists(); // ok

let prettySure: Object = 4;
prettySure.toFixed(); // Error: Property 'toFixed' doesn't exit on type 'Object'.
</code></pre> <p><strong>void</strong></p> <p>表示没有任何类型. 当一个函数没有返回值时,通常会见到其返回值是void.</p> <pre><code>function warnUser(): void {
    console.log(&quot;This is my waring message&quot;);
}

// void 类型的变量只能被赋予 undefined 和 null
let unusable: void = undefined;
</code></pre> <p><strong>Never</strong></p> <p>never 类型表示的是那些永不存在值的类型.   never类型是任何类型的子类型, 也可以赋值给任何类型.</p> <pre><code>// 返回never 的函数必须存在无法到达的终点
function error(message: string): never {
    throw new Error(message);
}

function infiniteLoop(): never {
    while (true) {
        xxx;
    }
}

// 推断的返回值类型为 never
function fail() {
    return error('Something failed')
}
</code></pre> <p><strong>类型断言</strong></p> <p>类型断言就是程序员已经判断好了类型, 替代编译器进行特殊的数据检查和解构.</p> <pre><code>let someValue: any = 'This is a string';
let strLength: number = (&lt;string&gt;someValue).length;

let strLength: number = (someValue as string).length;
// JSX 只有 as 语法断言是被允许的
</code></pre> <h3 id="变量声明"><a href="#变量声明" aria-hidden="true" class="header-anchor">#</a> 变量声明</h3> <p><code>var let const</code></p> <h3 id="接口"><a href="#接口" aria-hidden="true" class="header-anchor">#</a> 接口</h3> <p>TypeScript的核心原则之一是对值所具有的结构进行类型检查. 它有时被称为&quot;鸭式辨型法&quot;或&quot;结构性子类型化&quot;.</p> <p>在TypeScript里, 接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约.</p> <p><strong>普通对象</strong></p> <pre><code>// 必须属性
interface LabelledValue {
    label: string;
}

// 可选属性
interface SquareConfig {
    color?: string
}
 
// 只读属性
interface Point {
    readonly x: number
}

// 额外属性检查
interface SquareConfig {
    color: string;
    width: number;
    [propName: string]: any
}
</code></pre> <p><strong>函数类型</strong></p> <pre><code>// 只有参数列表和返回值类型的函数定义
interface SearchFunc {
    (source: string, subString: string) : boolean;
}
</code></pre> <p><strong>可索引类型</strong></p> <pre><code>// 描述那些能够通过索引得到的类型 比如 a[10]
interface StringArray {
    [index: number]: string
}

// ts 支持两种索引签名: 字符串和数字. 数字索引的返回值必须是字符串索引返回值类型的子类型.
// 当使用 number 来索引时, JavaScript 会将它转换成 string 然后再去索引对象. 也就是说 100 = &quot;100&quot;.

// 字符串索引签名能够很好的描述 dictionary 模式, 并且
</code></pre> <p><strong>接口的可继承性</strong></p> <pre><code>interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}

let square = &lt;Square&gt;{};
square.color = &quot;blue&quot;;
square.sideLength = 10;
square.penWidth = 5.0;
</code></pre> <p><strong>混合类型</strong></p> <pre><code>interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = &lt;Counter&gt;function (start: number) { };
    counter.interval = 123;
    counter.reset = function () {};
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
</code></pre> <h3 id="类"><a href="#类" aria-hidden="true" class="header-anchor">#</a> 类</h3> <pre><code>class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet () {
        return &quot;Hello, &quot; + this.greeting;
    }
}

let greeter = new Greeter('world');

class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log(&quot;slithering...&quot;);
        super.move(distanceInMeters);
    }
}

let tom: Animal = new Snake(&quot;Sammy the Python&quot;);

tom.move(34);
</code></pre> <p>派生类包含了一个构造函数, 它必须调用 super(), 它会执行基类的构造函数.</p> <p>而且在构造函数里访问this 的属性之前, 我们一定要调用 super()</p> <h3 id="函数"><a href="#函数" aria-hidden="true" class="header-anchor">#</a> 函数</h3> <p>为函数定义类型</p> <pre><code>function add (x: number, y:number): number {
    return x + y;
}
</code></pre> <p>可选参数和默认参数</p> <pre><code>// 可选参数在参数旁使用 ? 实现可选参数的功能 (可选参数一定要放在最后面, 而且要对其进行处理)
function buildName (firstName: string, lastName?: string) {
    if (lastName) {
        return firstName + &quot; &quot; + lastName;
    } else {
        return lastName;
    }
}

// 默认参数 (带默认值的参数不需要放在最后, 用户只需要明确地传入 undefined 值来获得默认值就可以)
function buildName (firstName: string, lastName = &quot;Smith&quot;, addName: string) {
    return firstName + &quot; &quot; + lastName;
}

let result = buildName(&quot;Bob&quot;, ,&quot;Sr.&quot;)
</code></pre> <p>剩余参数</p> <pre><code>// 同时操作多个参数, 但是并不知道会有多少个参数传进来
function buildName(firstName: string, ...restOfName: string[]) {
    return firstName + &quot; &quot; + restOfName.join(&quot;&quot;);
}

let employeeName = buildName(&quot;Joseph&quot;, &quot;Samuel&quot;, &quot;Lucas&quot;, &quot;Mackinzie&quot;);
</code></pre> <p>this指向 顶级的非方法式调用会将 this 视为 window (注: 在严格模式下, this为 undefined )</p> <p>函数重载 (函数名一样, 参数不一样, 不同的处理方法)</p> <h3 id="泛型"><a href="#泛型" aria-hidden="true" class="header-anchor">#</a> 泛型</h3> <p>创建可重用的组件, 一个组件可以支持多种类型的数据.</p> <pre><code>// T 是类型变量 它是一种特殊的变量, 表示的是类型 而不是值
function identity&lt;T&gt;(arg: T): T {
    return arg;
}

let output = identity&lt;string&gt;(&quot;myString&quot;); // type of output will be &quot;string&quot;

let output = identity(&quot;myString&quot;); // 类型推论(帮助我们保持代码精简和高可读性)

// 创建 T 类型的数组 而不直接是T
function loggingIdentity&lt;T&gt;(arg: T[]):T {
    console.log(arg.length);
    return arg;
}
</code></pre> <h3 id="枚举"><a href="#枚举" aria-hidden="true" class="header-anchor">#</a> 枚举</h3> <p>TypeScript支持数字和基于字符串的枚举.</p> <pre><code>// 数字枚举 (自增长行为)
enum Direction {
    Up = 1, // 不设置值的时候默认从 0 开始
    Down, // 2
    Left, // 3
    Right // 4
}

// 字符串枚举 (没有自增长行为,每个成员都必须用字符串自变量)
enum Direction {
    Up = &quot;Up&quot;,
    Down = &quot;Down&quot;,
    Left = &quot;Left&quot;,
    Right = &quot;Right&quot;
}

// 异构枚举 (不建议)
enum BooleanLikeHeterogenneousEnum {
    No = 0;
    Yes = &quot;YES&quot;,
}

// 反向映射
enum Enum {
    A
}
let a = Enum.A;
let nameOfA = Enum[a]; // &quot;A&quot;
</code></pre> <h3 id="类型推论"><a href="#类型推论" aria-hidden="true" class="header-anchor">#</a> 类型推论</h3> <p>TypeScript里, 在有些没有明确指出类型的地方, 类型推论会帮助提供类型.</p> <pre><code>// 发生在初始化变量和成员, 设置默认值和决定函数返回值时
let x = 3; // x =&gt; 数字

// 按照上下文分类
function crreateZoo(): Animal[] {
    return [new Rhino(), new Elephant(), new Snake()];
}
// 在这个例子里, 最佳通用类型有4个候选者: Animal, Rhino, Elephant, Snake. 当然, Animal 会被作为最佳通用类型.
</code></pre> <h3 id="类型兼容性"><a href="#类型兼容性" aria-hidden="true" class="header-anchor">#</a> 类型兼容性</h3> <p>TypeScript结构化类型系统的基本规则是: 如果x要兼容y, 那么y至少具有与x相同的属性.</p> <pre><code>interface Named {
    name: string;
}

let x: Named;
// Y's inferred type is { name: string; location: string; }
let y = { name: &quot;Alice&quot;, location: &quot;Seattle&quot; };
x = y;
// x 必须包含名字是 name 的 string 类型成员. y 满足条件, 因此赋值正确.
</code></pre> <p>检查函数参数时 使用相同的规则.</p> <h3 id="高级类型"><a href="#高级类型" aria-hidden="true" class="header-anchor">#</a> 高级类型</h3> <p>交叉类型 (Intersection Types) : 将多个类型合并为一个类型</p> <pre><code>function extend&lt;T, U&gt;(first: T, second: U): T &amp; U {
    let result = &lt;T &amp; U&gt;{ };
    for (let id in first) {
        (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id];
    }
    for (let id in second) {
        if (!result.hasOwnProperty(id)) {
            (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id];
        }
    }
    return result;
}
</code></pre> <p>联合类型 (Union Types) : 与交叉类型很有关联, 但是使用上完全不同</p> <pre><code>function padLeft(value: string, padding: string | number) {
    xxx;
}

let indentedString = padLeft(&quot;Hello world&quot;, true);
</code></pre> <p>类型保护与区分类型(Type Guards and Differentiating Types)</p> <p>typeof 类型保护</p> <pre><code>function padLeft(value: string, padding: string | number) {
    if (typeof padding === 'number') {
        xxx;
    }
    if (typeof padding === 'string') {
        xxx;
    }
}
</code></pre> <p>instanceof 类型保护</p> <p>instanceof 的右侧要求是一个构造函数, TypeScript将细化为:</p> <ol><li>此构造函数的 prototype 属性的类型, 如果它的类型不为 any 的话</li> <li>构造签名所返回的类型的联合</li></ol> <h3 id="symbol"><a href="#symbol" aria-hidden="true" class="header-anchor">#</a> Symbol</h3> <p>symbol 是一种新的原生类型. Symbols 是不可改变且唯一的.</p> <pre><code>let sym1 = Symbol();
let sym2 = Symbol(&quot;key&quot;); // 可选的字符串key

let sym = Symbol();

let obj = {
    [sym]: &quot;value&quot;
};

console.log(obj[sym]); // &quot;value&quot;
</code></pre> <h3 id="迭代器和生成器"><a href="#迭代器和生成器" aria-hidden="true" class="header-anchor">#</a> 迭代器和生成器</h3> <p>for...in 和 for...of 语句</p> <pre><code>let list = [3, 4, 5];

for (let i in list) {
    console.log(i); // '0', '1', '2'
}

for (let i of list) {
    console.log(i); // '3' ,'4', '5'
}

// 另一个区别是 for...in 可以操作任何对象, 它提供了查看对象属性的方法
// for...of 关注于迭代对象的值

list[3] = 6;

for (let i in list) {
    console.log(i); // 6
}

for (let i of list) {
    console.log(i); // '3', '4', '5'
}

// for...of 可以使用 break 语句打断循环.
</code></pre> <h3 id="模块"><a href="#模块" aria-hidden="true" class="header-anchor">#</a> 模块</h3> <p>导入和导出 <em>外部文件</em></p> <pre><code>export =&gt; import ... from &quot;...&quot;
export = obj =&gt; import ... = require(&quot;...&quot;)
</code></pre> <h3 id="命名空间"><a href="#命名空间" aria-hidden="true" class="header-anchor">#</a> 命名空间</h3> <p>namespace <em>内部文件</em></p> <pre><code>namespace Shapes {
    export namespace Ploygons {
        export class Triangle { }
        export class Square { }
    }
}

import polygons = Shapes.Polygons;
let sq = new polygons.Square(); // Same as &quot;new Shapes.Ploygons.Square()&quot;
</code></pre></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.6c972312.js" defer></script><script src="/assets/js/5.94bb3ea4.js" defer></script>
  </body>
</html>
